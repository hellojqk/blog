# 系统问题

- [进程（Process）和线程（Thread）的区别](进程（Process）和线程（Thread）的区别)
- [docker容器中的1号进程是我们定义应用程序进程](docker容器中的1号进程是我们定义应用程序进程)

## 进程（Process）和线程（Thread）的区别

### 基本区别

- 进程是操作系统资源分配的基本单位，线程是CPU任务调度和执行的基本单位，一个进程至少包含一个线程
- 进程有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销。线程可以看做轻量级的进程`Lightweight Process，LWP`，同一进程内的线程共享代码和数据空间，有自己独立的运行栈和程序计数器（PC），相对于进程来说开销小。
  - 体会游戏多开时，来回切换经常会卡顿

### 用户线程和内核线程

- 内核线程 依赖CPU核心，位于CPU中。cpu常见宣传语`4核8线程`、`6核12线程`，指的就是内核线程，基于物理核的超线程技术。
  - `百科-超线程` 摘要：早期CPU是单核的，英特尔通过超线程技术使得1个物理芯片提供2个内核线程，可以在一个物理芯片上使用线程级的`并行`计算。
    - SIMD（Single  Instruction  Multiple  Data  stream，即单指令多数据流）
    - SSE（Streaming  SIMD  Extensions，即“流式”单指令多数据流“扩展”）
  - 一颗物理芯片上的超线程的性能并不等于两个CPU的性能。当两个线程同时需要某个资源时，其中一个线程必须让出资源暂时挂起，直到这些资源空闲以后才能继续.
  - 超线程技术的CPU需要芯片组、操作系统和应用软件的支持
- 用户线程 不依赖CPU核心，位于用户进程内。 应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。

### 协作式与抢占式

- 协作式调度允许任务执行任意长的时间，直到任务主动通知调度器让出资源
- 抢占式调度允许任务在执行过程中被调度器挂起，调度器会重新决定下一个运行的任务

### 内核态和用户态

- 内核态 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。
  - 进程（线程）管理 （进程或者线程的调度）
  - 低级存储器管理 （用户程序逻辑空间到内存空间的物理地址的变换）（逻辑---> 物理映射）
  - I/O指令、置终端屏蔽指令、清内存、建存储保护、设置时钟指令。
  - 中断、异常、陷入，比如缺页中断等
  - 系统调用，比如调用了设备驱动程序
- 用户态 应用程序执行函数运算等。


### 并行（concurrency）和并发（parallellism）

- 时间上
  - 并行是指两个或多个事件在`同一时刻`发生
  - 并发是指两个或多个事件在`同一时间间隔`发生
- 空间上
  - 并行是在`不同实体`上的多个事件
  - 并发是在`同一实体`上的多个事件

### 扩展到go语言

- M Machine
  - 内核线程的封装，数量与内核线程对应。
- P Processor
  - G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数。
- G Goroutine
  - 用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息。

Goroutine是Go语言中最基本的执行单位。存在`G>M`或`G<M`数量的情况。go应用本身维护了一个全局G队列，没有P的情况下，M从全局G队列中获取G并执行，需要加锁，就存在性能损失，所以增加了P。

P与M对应，P为M维护一个自身的G队列，那么多个M在并行计算时,只需从自身的G队列中获取并执行。如果自身的G队列没有了待执行G,那么则依次从全局，其他P队列中检索一个G并执行。


参考：[go调度器](https://changkun.de/golang/zh-cn/part2runtime/ch06sched/basic/)

### 一些知识

- docker容器中的1号进程是我们定义应用程序进程
